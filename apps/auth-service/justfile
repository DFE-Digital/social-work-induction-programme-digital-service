set shell := ["pwsh", "-nop", "-c"]

solution-root := "Dfe.Sww.Ecf"
solution-dir := justfile_directory() / solution-root
user-secrets-id := "Dfe.Sww.Ecf"
cli-user-secrets-id := "Dfe.Sww.Ecf.Cli"
test-user-secrets-id := "Dfe.Sww.EcfTests"
ci := "false"

mod onelogin-sim

default:
  @just --list

# Install local tools
install-tools:
  @cd {{solution-root}} && dotnet tool restore
  npm install -g sass

ci-install-tools:
  @just install-tools

# Restore dependencies
restore:
  @cd {{solution-root}} && dotnet restore
  @cd {{solution-root / "src" / "Dfe.Sww.Ecf.AuthorizeAccess" }} && dotnet libman restore --verbosity quiet

ci-restore:
  @just restore

# Run the ecfcli
cli *ARGS:
  @cd {{solution-root / "src" / "Dfe.Sww.Ecf.Cli"}} && dotnet {{"bin" / "Debug" / "net8.0" / "ecfcli.dll"}} {{ARGS}}

# Build the .NET solution
build:
  @cd {{solution-root}} && dotnet build

ci-build:
  @just build

build-project project:
  @dotnet build {{solution-root}}/src/{{project}}

# Test the .NET solution
test:
  #!/bin/bash
  set -uo pipefail

  DB_USER="${DB_USER:-postgres}"
  DB_PASSWORD="${DB_PASSWORD:-swpdp}"
  DB_NAME="${DB_NAME:-swpdp}"
  DB_PORT="${DB_PORT:-5432}"
  DB_HOST="${DB_HOST:-127.0.0.1}"
  DB_CONTAINER="auth-tests-postgres"

  echo "Starting Postgres container '$DB_CONTAINER' for tests‚Ä¶"
  docker rm -f "$DB_CONTAINER" >/dev/null 2>&1 || true
  docker run -d --rm --name "$DB_CONTAINER" \
    -e POSTGRES_USER="$DB_USER" \
    -e POSTGRES_PASSWORD="$DB_PASSWORD" \
    -e POSTGRES_DB="$DB_NAME" \
    -p "${DB_PORT}:5432" \
    postgres:15 >/dev/null

  cleanup() {
    local exit_code=${1:-0}
    echo "Cleaning up database container..."
    docker rm -f "$DB_CONTAINER" >/dev/null 2>&1 || true
    echo "Exiting..."
    exit $exit_code
  }
  trap cleanup EXIT SIGINT SIGTERM

  cleanup_fail() {
    echo "Logs from '$DB_CONTAINER' (tail):"
    docker logs "$DB_CONTAINER" --tail 100 || true
    cleanup 1
  }
  trap cleanup_fail SIGHUP ERR


  echo "Waiting for Postgres to become ready‚Ä¶"
  for i in {1..40}; do
    if docker exec -e PGPASSWORD="$DB_PASSWORD" "$DB_CONTAINER" \
        pg_isready -U "$DB_USER" -d "$DB_NAME" >/dev/null 2>&1; then
      break
    fi
    sleep 2
  done
  if ! docker exec -e PGPASSWORD="$DB_PASSWORD" "$DB_CONTAINER" \
        pg_isready -U "$DB_USER" -d "$DB_NAME" >/dev/null 2>&1; then
    echo "ERROR: Postgres (DB '$DB_NAME') did not become healthy in time." >&2
    exit 1
  fi

  echo "Postgres (DB '$DB_NAME') ready!"

  cd "{{solution-dir}}"

  mapfile -t TEST_PROJECTS < <(find . -path "./tests/*/*.Tests.csproj" | sort)

  if (( ${#TEST_PROJECTS[@]} == 0 )); then
    echo "No test projects found!" >&2
    exit 1
  fi

  echo "Found test projects:"
  printf ' - %s\n' "${TEST_PROJECTS[@]}"

  export ASPNETCORE_ENVIRONMENT="${ASPNETCORE_ENVIRONMENT:-Testing}"
  export ConnectionStrings__DefaultConnection="Host=${DB_HOST};Port=${DB_PORT};Database=${DB_NAME};Username=${DB_USER};Password=${DB_PASSWORD}"

  DOTNET_ARGS=("$@")

  SUMMARY_CAPTURE=""
  if [[ -n "${GITHUB_STEP_SUMMARY:-}" && -n "${RUNNER_TEMP:-}" ]]; then
    SUMMARY_CAPTURE="${RUNNER_TEMP%/}/auth-service-test-summary-$(date +%s)-$RANDOM.md"
    : > "$SUMMARY_CAPTURE"
    echo "TEST_SUMMARY_HTML=$SUMMARY_CAPTURE" >> "$GITHUB_ENV"
  fi

  if [[ "${GITHUB_ACTIONS:-}" == "true" || "${CI:-{{ci}}}" == "true" ]]; then
    DOTNET_ARGS+=(--no-build)
    DOTNET_ARGS+=(--logger "GitHubActions;summary.includePassedTests=true;summary.includeSkippedTests=true")
    DOTNET_ARGS+=(-- "RunConfiguration.CollectSourceInformation=true")
  fi

  overall=0
  for csproj in "${TEST_PROJECTS[@]}"; do
    echo "::group::dotnet test $csproj ${DOTNET_ARGS[*]}"
    if [[ -n "$SUMMARY_CAPTURE" ]]; then
      if ! GITHUB_STEP_SUMMARY="$SUMMARY_CAPTURE" dotnet test "$csproj" "${DOTNET_ARGS[@]}"; then
        echo "::error title=Tests failed::$csproj"
        overall=1
      else
        echo "Tests passed in $csproj"
      fi
    else
      if ! dotnet test "$csproj" "${DOTNET_ARGS[@]}"; then
        echo "::error title=Tests failed::$csproj"
        overall=1
      else
        echo "Tests passed in $csproj"
      fi
    fi
    echo "::endgroup::"
  done
  
  exit $overall

ci-test:
  @just ci=true test

# Format the .NET solution and Terraform code
format:
  @cd {{solution-root}} && dotnet format
  @terraform fmt terraform/aks

# Format any un-committed .tf or .cs files
format-changed:
  #!pwsh -nop

  function Get-ChangedFiles {
    param (
      $Path
    )

    (git status --porcelain $Path) | foreach { $_.substring(3) } | Where-Object { Test-Path $_ }
  }

  $changedTfFiles = Get-ChangedFiles "terraform/*.tf"
  foreach ($tf in $changedTfFiles) {
    terraform fmt $tf
  }

  $changedCsFiles = (Get-ChangedFiles "{{solution-root}}/**/*.cs") | foreach { $_ -Replace "^{{solution-root}}/", "" }
  if ($changedCsFiles.Length -gt 0) {
    $dotnetArgs = @("format", "--no-restore", "--include") + $changedCsFiles
    cd {{solution-root}} && dotnet $dotnetArgs
  }

# Run the EF Core Command-line Tools for the Core project
ef *ARGS:
  @cd {{solution-root / "src" / "Dfe.Sww.Ecf.Core"}} && dotnet dotnet-ef {{ARGS}}

# Run the AuthorizeAccess project in Development mode and watch for file changes
watch-authz:
  @cd {{solution-root / "src" / "Dfe.Sww.Ecf.AuthorizeAccess"}} && dotnet watch

publish:
  @cd {{solution-root}} && dotnet publish -c Release --no-restore

publish-project project:
  @dotnet publish {{solution-root}}/src/{{project}} -c Release --no-restore

package-component:
  @dotnet publish {{solution-root}}/src/Dfe.Sww.Ecf.AuthorizeAccess -c Release --no-restore
  @dotnet publish {{solution-root}}/src/Dfe.Sww.Ecf.Cli -c Release --no-restore

ci-package-component:
  @just package-component

# Build the Docker image
docker-build *ARGS: install-tools restore
  @cd {{solution-root}} && dotnet publish -c Release --no-restore
  @cd {{solution-root}} && docker build . {{ARGS}}

set-db-connection value:
  @dotnet user-secrets set ConnectionStrings:DefaultConnection "{{value}}" --id {{user-secrets-id}}
  @dotnet user-secrets set ConnectionStrings:DefaultConnection "{{value}}" --id {{cli-user-secrets-id}}

set-test-db-connection value:
  @dotnet user-secrets set ConnectionStrings:DefaultConnection "{{value}}" --id {{test-user-secrets-id}}
  @dotnet user-secrets set ConnectionStrings:TestDbConnection "{{value}}" --id {{cli-user-secrets-id}}

# Set a configuration entry in user secrets for running the apps
set-secret key value:
  @dotnet user-secrets set "{{key}}" "{{value}}" --id {{user-secrets-id}}

# Set a configuration entry in user secrets for tests
set-tests-secret key value:
  @dotnet user-secrets set "{{key}}" "{{value}}" --id {{test-user-secrets-id}}

create-admin email name:
  @cd {{solution-root / "src" / "Dfe.Sww.Ecf.Cli"}} && dotnet {{"bin" / "Debug" / "net8.0" / "ecfcli.dll"}} create-admin --email {{email}} --name {{quote(name)}}

make *ARGS:
  @make {{ARGS}}

# Removes the cached DB schema version file for tests
remove-tests-schema-cache:
  @scripts/Remove-TestsSchemaCache.ps1

database-updates resource-group web-app-name full-image-tag:
  #!/bin/bash
  set -xeuo pipefail

  # At this point, the github actions workflow has already established an SSH tunnel
  # to the remote database server
  IMAGE_TAG={{ full-image-tag }}
  # All of these environment variables have been fetched from the app service by the
  # github workflow
  DB_CONNECTION_STRING="Host=127.0.0.1;Database=$DB_DATABASE_NAME;Username=$DB_USER_NAME;Password=$DB_PASSWORD;Ssl Mode=Require;Trust Server Certificate=false"
  echo "üê≥ Pulling migrations image $IMAGE_TAG"
  docker pull "$IMAGE_TAG"

  # CONNECTIONSTRINGS__DEFAULTCONNECTION and DB_PASSWORD satisfy the startup 
  # requirement of the image DB_CONNECTION_STRING is used by the CLI
  echo "üîÑ Executing database migrations..."
  docker run --rm \
    --name migrate-db \
    --network host \
    -e DB_CONNECTION_STRING="$DB_CONNECTION_STRING" \
    -e CONNECTIONSTRINGS__DEFAULTCONNECTION="$DB_CONNECTION_STRING" \
    -e DB_PASSWORD="$DB_PASSWORD" \
    "$IMAGE_TAG" \
    sh -c '
      cd /Apps/EcfCli
      dotnet ecfcli.dll migrate-db --connection-string "$DB_CONNECTION_STRING"
    '

  echo "‚úÖ Migrations completed."
