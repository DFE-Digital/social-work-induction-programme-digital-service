name: DB backup and restore

on:
  workflow_call:
    inputs:
      environment:
        description: "The GitHub environment to run the workflow against"
        type: string
        required: true
      action:
        description: "The action to perform (backup or restore)"
        required: true
        type: string
      db-name:
        description: "The actual database name to backup or restore (e.g., s205d01_db_moodle_primary)"
        required: true
        type: string
      container-suffix:
        description: "The suffix to use for container naming (e.g., moodle, usermanagement)"
        required: true
        type: string
      backup-file-name:
        description: "The name of the backup file in Blob Storage to restore from (required when action is 'restore')"
        required: false
        type: string
      instance:
        description: "The environment instance to operate on (e.g., d01, d02, d03)"
        required: true
        type: string
    secrets:
      AZ_CLIENT_ID:
        required: true
      AZ_TENANT_ID:
        required: true
      AZ_SUBSCRIPTION_ID:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  backup:
    if: inputs.action == 'backup'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Login to Azure
        uses: azure/login@a457da9ea143d694b1b9c7c869ebb04ebe844ef5 # v2
        with:
          client-id: ${{ secrets.AZ_CLIENT_ID }}
          tenant-id: ${{ secrets.AZ_TENANT_ID }}
          subscription-id: ${{ secrets.AZ_SUBSCRIPTION_ID }}

      - name: Get Function Key from Key Vault
        run: |
          FUNCTION_KEY=$(az keyvault secret show \
            --name "DbOperationsService-FunctionKey" \
            --vault-name "s205${{ inputs.instance }}-kv-primary" \
            --query value -o tsv)

          # Mask the secret to prevent it from appearing in logs
          echo "::add-mask::$FUNCTION_KEY"

          echo "FUNCTION_KEY=$FUNCTION_KEY" >> $GITHUB_ENV

      - name: Validate inputs
        run: |
          # Validate action parameter
          if [ "${{ inputs.action }}" != "backup" ] && [ "${{ inputs.action }}" != "restore" ]; then
            echo "Error: Invalid action '${{ inputs.action }}'. Must be 'backup' or 'restore'."
            exit 1
          fi

          # Validate that backup operations don't have a backup file name (should be empty)
          if [ "${{ inputs.action }}" = "backup" ] && [ -n "${{ inputs.backup-file-name }}" ]; then
            echo "Error: backup-file-name should not be provided when action is 'backup'"
            exit 1
          fi

      - name: Backup ${{ inputs.db-name }} database on ${{ inputs.instance }}
        run: |
          FUNCTION_APP_NAME="s205${{ inputs.instance }}-fa-db-jobs"
          ENDPOINT="https://$FUNCTION_APP_NAME.azurewebsites.net/api/DbOperationsFunction"
          STORAGE_ACCOUNT="s205${{ inputs.instance }}sabackups"
          CONTAINER="s205${{ inputs.instance }}-${{ inputs.container-suffix }}-backups"

          JSON_PAYLOAD=$(cat <<EOF
          {
            "action": "backup",
            "databaseName": "${{ inputs.db-name }}",
            "storageAccount": "$STORAGE_ACCOUNT",
            "containerName": "$CONTAINER"
          }
          EOF
          )

          echo "DB Operation: backup ${{ inputs.db-name }} on ${{ inputs.instance }}"
          echo "Using Function App: $FUNCTION_APP_NAME"
          echo "Container: $CONTAINER"
          echo "Endpoint: $ENDPOINT"

          RESPONSE=$(curl -X POST "$ENDPOINT?code=$FUNCTION_KEY" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            -w "\nHTTP_STATUS:%{http_code}")

          HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d')

          echo "Response status: $HTTP_STATUS"
          echo "Response body: $RESPONSE_BODY"

          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "DB operation failed: backup ${{ inputs.db-name }} on ${{ inputs.instance }}"
            exit 1
          fi

  restore:
    if: inputs.action == 'restore'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Validate backup file name
        run: |
          if [ -z "${{ inputs.backup-file-name }}" ]; then
            echo "Error: backup-file-name is required when action is 'restore'"
            exit 1
          fi

      - name: Login to Azure
        uses: azure/login@a457da9ea143d694b1b9c7c869ebb04ebe844ef5 # v2
        with:
          client-id: ${{ secrets.AZ_CLIENT_ID }}
          tenant-id: ${{ secrets.AZ_TENANT_ID }}
          subscription-id: ${{ secrets.AZ_SUBSCRIPTION_ID }}

      - name: Get Function Key from Key Vault
        run: |
          FUNCTION_KEY=$(az keyvault secret show \
            --name "DbOperationsService-FunctionKey" \
            --vault-name "s205${{ inputs.instance }}-kv-primary" \
            --query value -o tsv)

          # Mask the secret to prevent it from appearing in logs
          echo "::add-mask::$FUNCTION_KEY"

          echo "FUNCTION_KEY=$FUNCTION_KEY" >> $GITHUB_ENV

      - name: Validate inputs
        run: |
          # Validate action parameter
          if [ "${{ inputs.action }}" != "backup" ] && [ "${{ inputs.action }}" != "restore" ]; then
            echo "Error: Invalid action '${{ inputs.action }}'. Must be 'backup' or 'restore'."
            exit 1
          fi

          # Validate that restore operations have a backup file name
          if [ "${{ inputs.action }}" = "restore" ] && [ -z "${{ inputs.backup-file-name }}" ]; then
            echo "Error: backup-file-name is required when action is 'restore'"
            exit 1
          fi

      - name: Start Restore ${{ inputs.db-name }} database on ${{ inputs.instance }}
        run: |
          FUNCTION_APP_NAME="s205${{ inputs.instance }}-fa-db-jobs"
          ENDPOINT="https://$FUNCTION_APP_NAME.azurewebsites.net/api/DbOperationsFunction"
          STORAGE_ACCOUNT="s205${{ inputs.instance }}sabackups"
          CONTAINER="s205${{ inputs.instance }}-${{ inputs.container-suffix }}-backups"

          JSON_PAYLOAD=$(cat <<EOF
          {
            "action": "restore",
            "databaseName": "${{ inputs.db-name }}",
            "storageAccount": "$STORAGE_ACCOUNT",
            "containerName": "$CONTAINER",
            "backupFileName": "${{ inputs.backup-file-name }}",
            "async": true
          }
          EOF
          )

          echo "Starting async restore of ${{ inputs.db-name }} on ${{ inputs.instance }}"
          echo "Using Function App: $FUNCTION_APP_NAME"
          echo "Container: $CONTAINER"
          echo "Endpoint: $ENDPOINT"

          RESPONSE=$(curl -X POST "$ENDPOINT?code=$FUNCTION_KEY" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            -w "\nHTTP_STATUS:%{http_code}")

          HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d')

          echo "Response status: $HTTP_STATUS"
          echo "Response body: $RESPONSE_BODY"

          if [ "$HTTP_STATUS" -ne 202 ]; then
            echo "Failed to start async restore: $RESPONSE_BODY"
            exit 1
          fi

          # Extract status URL from JSON response
          STATUS_URL=$(echo "$RESPONSE_BODY" | jq -r '.statusUrl')
          if [ -z "$STATUS_URL" ] || [ "$STATUS_URL" = "null" ]; then
            echo "Could not extract status URL from response"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi

          echo "STATUS_URL=$STATUS_URL" >> $GITHUB_ENV
          echo "Async restore started. Status URL: $STATUS_URL"

      - name: Monitor Restore Progress
        run: |
          MAX_ATTEMPTS=240  # 4 hours with 1-minute intervals (adjust as needed)
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            echo "Checking status (attempt $((ATTEMPT+1))/$MAX_ATTEMPTS)..."

            RESPONSE=$(curl -s "$STATUS_URL&code=$FUNCTION_KEY")
            HTTP_STATUS=$?

            if [ $HTTP_STATUS -ne 0 ]; then
              echo "Failed to check status: HTTP $HTTP_STATUS"
              sleep 60
              ATTEMPT=$((ATTEMPT+1))
              continue
            fi

            # Parse JSON response
            STATUS=$(echo "$RESPONSE" | jq -r '.status')
            MESSAGE=$(echo "$RESPONSE" | jq -r '.message')

            case "$STATUS" in
              "completed")
                echo "✅ Restore completed successfully!"
                echo "Message: $MESSAGE"
                echo "Full response: $RESPONSE"
                exit 0
                ;;
              "failed")
                echo "❌ Restore failed!"
                echo "Message: $MESSAGE"
                echo "Full response: $RESPONSE"
                exit 1
                ;;
              "running")
                echo "⏳ Restore still running... (attempt $((ATTEMPT+1))/$MAX_ATTEMPTS)"
                echo "Message: $MESSAGE"
                sleep 60
                ATTEMPT=$((ATTEMPT+1))
                ;;
              "not_found")
                echo "❌ Job not found!"
                echo "Message: $MESSAGE"
                exit 1
                ;;
              "error")
                echo "❌ Status check error!"
                echo "Message: $MESSAGE"
                exit 1
                ;;
              *)
                echo "⚠️  Unexpected status: $STATUS"
                echo "Response: $RESPONSE"
                sleep 60
                ATTEMPT=$((ATTEMPT+1))
                ;;
            esac
          done

          echo "❌ Restore timed out after $MAX_ATTEMPTS attempts"
          exit 1
