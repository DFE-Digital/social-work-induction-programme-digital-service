name: DB backup and restore

on:
  workflow_call:
    inputs:
      environment:
        description: "The GitHub environment to run the workflow against"
        type: string
        required: true
      action:
        description: "The action to perform (backup or restore)"
        required: true
        type: string
      db-name:
        description: "The actual database name to backup or restore (e.g., s205d01_db_moodle_primary)"
        required: true
        type: string
      container-suffix:
        description: "The suffix to use for container naming (e.g., moodle, usermanagement)"
        required: true
        type: string
      backup-file-name:
        description: "The name of the backup file in Blob Storage to restore from (required when action is 'restore')"
        required: false
        type: string
      instance:
        description: "The environment instance to operate on (e.g., d01, d02, d03)"
        required: true
        type: string
    secrets:
      AZ_CLIENT_ID:
        required: true
      AZ_TENANT_ID:
        required: true
      AZ_SUBSCRIPTION_ID:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  backup:
    if: inputs.action == 'backup'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a #v2.13.1
        with:
          egress-policy: audit

      - name: Login to Azure
        uses: azure/login@a457da9ea143d694b1b9c7c869ebb04ebe844ef5 # v2
        with:
          client-id: ${{ secrets.AZ_CLIENT_ID }}
          tenant-id: ${{ secrets.AZ_TENANT_ID }}
          subscription-id: ${{ secrets.AZ_SUBSCRIPTION_ID }}

      - name: Get Function Key and Front Door URL from Key Vault
        run: |
          FUNCTION_KEY=$(az keyvault secret show \
            --name "DbOperationsService-FunctionKey" \
            --vault-name "s205${{ inputs.instance }}-kv-primary" \
            --query value -o tsv)

          FRONTDOOR_HOSTNAME=$(az keyvault secret show \
            --name "DbOperationsService-FrontDoorUrl" \
            --vault-name "s205${{ inputs.instance }}-kv-primary" \
            --query value -o tsv)

          # Mask the secrets to prevent them from appearing in logs
          echo "::add-mask::$FUNCTION_KEY"
          echo "::add-mask::$FRONTDOOR_HOSTNAME"

          echo "FUNCTION_KEY=$FUNCTION_KEY" >> $GITHUB_ENV
          echo "FRONTDOOR_HOSTNAME=$FRONTDOOR_HOSTNAME" >> $GITHUB_ENV

      - name: Validate inputs
        run: |
          # Validate action parameter
          if [ "${{ inputs.action }}" != "backup" ] && [ "${{ inputs.action }}" != "restore" ]; then
            echo "Error: Invalid action '${{ inputs.action }}'. Must be 'backup' or 'restore'."
            exit 1
          fi

          # Validate that backup operations don't have a backup file name (should be empty)
          if [ "${{ inputs.action }}" = "backup" ] && [ -n "${{ inputs.backup-file-name }}" ]; then
            echo "Error: backup-file-name should not be provided when action is 'backup'"
            exit 1
          fi

      - name: Backup ${{ inputs.db-name }} database on ${{ inputs.instance }}
        run: |
          FUNCTION_APP_NAME="s205${{ inputs.instance }}-fa-db-jobs"
          ENDPOINT="https://$FRONTDOOR_HOSTNAME/api/DbOperationsFunction"
          STORAGE_ACCOUNT="s205${{ inputs.instance }}sabackups"
          CONTAINER="s205${{ inputs.instance }}-${{ inputs.container-suffix }}-backups"

          JSON_PAYLOAD=$(cat <<EOF
          {
            "action": "backup",
            "databaseName": "${{ inputs.db-name }}",
            "storageAccount": "$STORAGE_ACCOUNT",
            "containerName": "$CONTAINER"
          }
          EOF
          )

          echo "DB Operation: backup ${{ inputs.db-name }} on ${{ inputs.instance }}"
          echo "Using Function App: $FUNCTION_APP_NAME"
          echo "Container: $CONTAINER"
          echo "Endpoint: $ENDPOINT"

          RESPONSE=$(curl -X POST "$ENDPOINT?code=$FUNCTION_KEY" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            -w "\nHTTP_STATUS:%{http_code}")

          HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d')

          echo "Response status: $HTTP_STATUS"
          echo "Response body: $RESPONSE_BODY"

          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "DB operation failed: backup ${{ inputs.db-name }} on ${{ inputs.instance }}"
            exit 1
          fi

  restore:
    if: inputs.action == 'restore'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Validate backup file name
        run: |
          if [ -z "${{ inputs.backup-file-name }}" ]; then
            echo "Error: backup-file-name is required when action is 'restore'"
            exit 1
          fi

      - name: Login to Azure
        uses: azure/login@a457da9ea143d694b1b9c7c869ebb04ebe844ef5 # v2
        with:
          client-id: ${{ secrets.AZ_CLIENT_ID }}
          tenant-id: ${{ secrets.AZ_TENANT_ID }}
          subscription-id: ${{ secrets.AZ_SUBSCRIPTION_ID }}

      - name: Get Function Key and Front Door URL from Key Vault
        run: |
          FUNCTION_KEY=$(az keyvault secret show \
            --name "DbOperationsService-FunctionKey" \
            --vault-name "s205${{ inputs.instance }}-kv-primary" \
            --query value -o tsv)

          FRONTDOOR_HOSTNAME=$(az keyvault secret show \
            --name "DbOperationsService-FrontDoorUrl" \
            --vault-name "s205${{ inputs.instance }}-kv-primary" \
            --query value -o tsv)

          # Mask the secrets to prevent them from appearing in logs
          echo "::add-mask::$FUNCTION_KEY"
          echo "::add-mask::$FRONTDOOR_HOSTNAME"

          echo "FUNCTION_KEY=$FUNCTION_KEY" >> $GITHUB_ENV
          echo "FRONTDOOR_HOSTNAME=$FRONTDOOR_HOSTNAME" >> $GITHUB_ENV

      - name: Validate inputs
        run: |
          # Validate action parameter
          if [ "${{ inputs.action }}" != "backup" ] && [ "${{ inputs.action }}" != "restore" ]; then
            echo "Error: Invalid action '${{ inputs.action }}'. Must be 'backup' or 'restore'."
            exit 1
          fi

          # Validate that restore operations have a backup file name
          if [ "${{ inputs.action }}" = "restore" ] && [ -z "${{ inputs.backup-file-name }}" ]; then
            echo "Error: backup-file-name is required when action is 'restore'"
            exit 1
          fi

      - name: Restore ${{ inputs.db-name }} database on ${{ inputs.instance }}
        run: |
          FUNCTION_APP_NAME="s205${{ inputs.instance }}-fa-db-jobs"
          ENDPOINT="https://$FRONTDOOR_HOSTNAME/api/DbOperationsFunction"
          STORAGE_ACCOUNT="s205${{ inputs.instance }}sabackups"
          CONTAINER="s205${{ inputs.instance }}-${{ inputs.container-suffix }}-backups"

          JSON_PAYLOAD=$(cat <<EOF
          {
            "action": "restore",
            "databaseName": "${{ inputs.db-name }}",
            "storageAccount": "$STORAGE_ACCOUNT",
            "containerName": "$CONTAINER",
            "backupFileName": "${{ inputs.backup-file-name }}"
          }
          EOF
          )

          echo "DB Operation: restore ${{ inputs.db-name }} on ${{ inputs.instance }}"
          echo "Using Function App: $FUNCTION_APP_NAME"
          echo "Container: $CONTAINER"
          echo "Endpoint: $ENDPOINT"

          RESPONSE=$(curl -X POST "$ENDPOINT?code=$FUNCTION_KEY" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            -w "\nHTTP_STATUS:%{http_code}")

          HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d')

          echo "Response status: $HTTP_STATUS"
          echo "Response body: $RESPONSE_BODY"

          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "DB operation failed: restore ${{ inputs.db-name }} on ${{ inputs.instance }}"
            exit 1
          fi
